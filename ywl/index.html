<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Compiler Lab website for NIT Calicut"><link href=https://silcnitc.github.io/expl-docs/ywl/ rel=canonical><link href=../yacc/ rel=prev><link href=../gdb/ rel=next><link rel=icon href=../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>Using lex with Yacc - EXPL NIT-C</title><link rel=stylesheet href=../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../extra.css><script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=purple data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#using-lex-with-yacc class=md-skip> Skip to content </a> </div> <div data-md-component=announce> <aside class=md-banner> <div class="md-banner__inner md-grid md-typeset"> <b>Site is undergoing migration.</b> Old URL: <a href=https://silcnitc.github.io target=_blank target=_blank rel="nofollow noopener">https://silcnitc.github.io</a> </div> </aside> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=.. title="EXPL NIT-C" class="md-header__button md-logo" aria-label="EXPL NIT-C" data-md-component=logo> <img src=../img/nitc-logo.png alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> EXPL NIT-C </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Using lex with Yacc </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme=default data-md-color-primary=purple data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5Z"/></svg> </label> <input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=slate data-md-color-primary=purple data-md-color-accent=indigo aria-label="Switch to light mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9v1Z"/></svg> </label> </form> <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=.. class=md-tabs__link> Home </a> </li> <li class=md-tabs__item> <a href=../about/philosophy/ class=md-tabs__link> About </a> </li> <li class=md-tabs__item> <a href=../roadmap/ class=md-tabs__link> Roadmap </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../documentation/ class=md-tabs__link> Documentation </a> </li> <li class=md-tabs__item> <a href=../feedback/ class=md-tabs__link> Student Feedback </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=.. title="EXPL NIT-C" class="md-nav__button md-logo" aria-label="EXPL NIT-C" data-md-component=logo> <img src=../img/nitc-logo.png alt=logo> </a> EXPL NIT-C </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=.. class=md-nav__link> <span class=md-ellipsis> Home </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex=0> <span class=md-ellipsis> About </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> About </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../about/philosophy/ class=md-nav__link> <span class=md-ellipsis> Philosophy </span> </a> </li> <li class=md-nav__item> <a href=../about/authors/ class=md-nav__link> <span class=md-ellipsis> Authors </span> </a> </li> <li class=md-nav__item> <a href=../about/license/ class=md-nav__link> <span class=md-ellipsis> License </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0> <span class=md-ellipsis> Roadmap </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=false> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Roadmap </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../roadmap/ class=md-nav__link> <span class=md-ellipsis> Roadmap </span> </a> </li> <li class=md-nav__item> <a href=../roadmap/stage-00/ class=md-nav__link> <span class=md-ellipsis> Stage 0 </span> </a> </li> <li class=md-nav__item> <a href=../roadmap/stage-01/ class=md-nav__link> <span class=md-ellipsis> Stage 1 </span> </a> </li> <li class=md-nav__item> <a href=../roadmap/stage-02/ class=md-nav__link> <span class=md-ellipsis> Stage 2 </span> </a> </li> <li class=md-nav__item> <a href=../roadmap/stage-03/ class=md-nav__link> <span class=md-ellipsis> Stage 3 </span> </a> </li> <li class=md-nav__item> <a href=../roadmap/stage-04/ class=md-nav__link> <span class=md-ellipsis> Stage 4 </span> </a> </li> <li class=md-nav__item> <a href=../roadmap/stage-05/ class=md-nav__link> <span class=md-ellipsis> Stage 5 </span> </a> </li> <li class=md-nav__item> <a href=../roadmap/stage-06/ class=md-nav__link> <span class=md-ellipsis> Stage 6 </span> </a> </li> <li class=md-nav__item> <a href=../roadmap/stage-07/ class=md-nav__link> <span class=md-ellipsis> Stage 7 </span> </a> </li> <li class=md-nav__item> <a href=../roadmap/stage-08/ class=md-nav__link> <span class=md-ellipsis> Stage 8 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4 checked> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex> <span class=md-ellipsis> Documentation </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=true> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Documentation </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../documentation/ class=md-nav__link> <span class=md-ellipsis> Documentation </span> </a> </li> <li class=md-nav__item> <a href=../codegen/ class=md-nav__link> <span class=md-ellipsis> Code Generation </span> </a> </li> <li class=md-nav__item> <a href=../abi/ class=md-nav__link> <span class=md-ellipsis> Application Binary Interface </span> </a> </li> <li class=md-nav__item> <a href=../libinterface/ class=md-nav__link> <span class=md-ellipsis> Library Implementation </span> </a> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_5> <label class=md-nav__link for=__nav_4_5 id=__nav_4_5_label tabindex> <span class=md-ellipsis> ExPL </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_4_5_label aria-expanded=false> <label class=md-nav__title for=__nav_4_5> <span class="md-nav__icon md-icon"></span> ExPL </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../expl/ class=md-nav__link> <span class=md-ellipsis> ExpL Specification </span> </a> </li> <li class=md-nav__item> <a href=../grammar-outline/ class=md-nav__link> <span class=md-ellipsis> ExpL Grammar Outline </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_5_3> <label class=md-nav__link for=__nav_4_5_3 id=__nav_4_5_3_label tabindex=0> <span class=md-ellipsis> Compile Time Data Structures for ExpL </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_5_3_label aria-expanded=false> <label class=md-nav__title for=__nav_4_5_3> <span class="md-nav__icon md-icon"></span> Compile Time Data Structures for ExpL </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../data-structures/ class=md-nav__link> <span class=md-ellipsis> Compile Time Data Structures for ExpL </span> </a> </li> <li class=md-nav__item> <a href=../data_structures/abstract-syntax-tree/ class=md-nav__link> <span class=md-ellipsis> Abstract Syntax Tree </span> </a> </li> <li class=md-nav__item> <a href=../data_structures/type-table/ class=md-nav__link> <span class=md-ellipsis> Type Table </span> </a> </li> <li class=md-nav__item> <a href=../data_structures/global-symbol-table/ class=md-nav__link> <span class=md-ellipsis> Global Symbol Table </span> </a> </li> <li class=md-nav__item> <a href=../data_structures/local-symbol-table/ class=md-nav__link> <span class=md-ellipsis> Local Symbol Table </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_5_4> <label class=md-nav__link for=__nav_4_5_4 id=__nav_4_5_4_label tabindex=0> <span class=md-ellipsis> Run Time Data Structures for ExpL </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_5_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4_5_4> <span class="md-nav__icon md-icon"></span> Run Time Data Structures for ExpL </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../run-data-structures/ class=md-nav__link> <span class=md-ellipsis> Run Time Data Structures for ExpL </span> </a> </li> <li class=md-nav__item> <a href=../run_data_structures/heap/ class=md-nav__link> <span class=md-ellipsis> Heap Allocation </span> </a> </li> <li class=md-nav__item> <a href=../run_data_structures/register/ class=md-nav__link> <span class=md-ellipsis> Register Allocation </span> </a> </li> <li class=md-nav__item> <a href=../run_data_structures/run-time-stack/ class=md-nav__link> <span class=md-ellipsis> Stack Allocation </span> </a> </li> <li class=md-nav__item> <a href=../run_data_structures/static-allocation/ class=md-nav__link> <span class=md-ellipsis> Static Allocation </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_5_5> <label class=md-nav__link for=__nav_4_5_5 id=__nav_4_5_5_label tabindex=0> <span class=md-ellipsis> ExPL Test Programs </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_5_5_label aria-expanded=false> <label class=md-nav__title for=__nav_4_5_5> <span class="md-nav__icon md-icon"></span> ExPL Test Programs </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../testprograms/ class=md-nav__link> <span class=md-ellipsis> Test Programs </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-01/ class=md-nav__link> <span class=md-ellipsis> Program 1 </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-02/ class=md-nav__link> <span class=md-ellipsis> Program 2 </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-03/ class=md-nav__link> <span class=md-ellipsis> Program 3 </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-04/ class=md-nav__link> <span class=md-ellipsis> Program 4 </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-05/ class=md-nav__link> <span class=md-ellipsis> Program 5 </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-06/ class=md-nav__link> <span class=md-ellipsis> Program 6 </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-07/ class=md-nav__link> <span class=md-ellipsis> Program 7 </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-08/ class=md-nav__link> <span class=md-ellipsis> Program 8 </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-09/ class=md-nav__link> <span class=md-ellipsis> Program 9 </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-10/ class=md-nav__link> <span class=md-ellipsis> Program 10 </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-11/ class=md-nav__link> <span class=md-ellipsis> Program 11 </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/test-program-12/ class=md-nav__link> <span class=md-ellipsis> Program 12 </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_5_5_14> <label class=md-nav__link for=__nav_4_5_5_14 id=__nav_4_5_5_14_label tabindex=0> <span class=md-ellipsis> Stage 4 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=4 aria-labelledby=__nav_4_5_5_14_label aria-expanded=false> <label class=md-nav__title for=__nav_4_5_5_14> <span class="md-nav__icon md-icon"></span> Stage 4 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../testprograms/stage4/bubblesort/ class=md-nav__link> <span class=md-ellipsis> Bubble Sort </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/stage4/fibaofn/ class=md-nav__link> <span class=md-ellipsis> Fibonacci </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/stage4/prime/ class=md-nav__link> <span class=md-ellipsis> Prime </span> </a> </li> <li class=md-nav__item> <a href=../testprograms/stage4/sum-to-n-fact/ class=md-nav__link> <span class=md-ellipsis> Sum to n! </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_6> <label class=md-nav__link for=__nav_4_6 id=__nav_4_6_label tabindex> <span class=md-ellipsis> OExpL </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_4_6_label aria-expanded=false> <label class=md-nav__title for=__nav_4_6> <span class="md-nav__icon md-icon"></span> OExpL </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../oexpl-specification/ class=md-nav__link> <span class=md-ellipsis> OExpL Specification </span> </a> </li> <li class=md-nav__item> <a href=../oexpl-grammar-outline/ class=md-nav__link> <span class=md-ellipsis> OExpL Grammar Outline </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_6_3> <label class=md-nav__link for=__nav_4_6_3 id=__nav_4_6_3_label tabindex=0> <span class=md-ellipsis> Compile Time Data Structures for OExpL </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_6_3_label aria-expanded=false> <label class=md-nav__title for=__nav_4_6_3> <span class="md-nav__icon md-icon"></span> Compile Time Data Structures for OExpL </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../oexpl-data-structures/ class=md-nav__link> <span class=md-ellipsis> Compile Time Data Structures for OExpL </span> </a> </li> <li class=md-nav__item> <a href=../oexpl_data_structures/class-table/ class=md-nav__link> <span class=md-ellipsis> Class Table </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_6_4> <label class=md-nav__link for=__nav_4_6_4 id=__nav_4_6_4_label tabindex=0> <span class=md-ellipsis> Run Time Data Structures for OExpL </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_6_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4_6_4> <span class="md-nav__icon md-icon"></span> Run Time Data Structures for OExpL </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../oexpl-run-data-structures/ class=md-nav__link> <span class=md-ellipsis> Run Time Data Structures for OExpL </span> </a> </li> <li class=md-nav__item> <a href=../oexpl_runtime_data_structures/virtual_function_table/ class=md-nav__link> <span class=md-ellipsis> Virtual Function Table </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../oexpl-runtime-binding-tutorial/ class=md-nav__link> <span class=md-ellipsis> OExPL Runtime Binding </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_6_6> <label class=md-nav__link for=__nav_4_6_6 id=__nav_4_6_6_label tabindex=0> <span class=md-ellipsis> OExPL Test Programs </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_6_6_label aria-expanded=false> <label class=md-nav__title for=__nav_4_6_6> <span class="md-nav__icon md-icon"></span> OExPL Test Programs </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../oexpl-testprograms/ class=md-nav__link> <span class=md-ellipsis> OExPL Test Programs </span> </a> </li> <li class=md-nav__item> <a href=../oexpltestprograms/test1/ class=md-nav__link> <span class=md-ellipsis> Program 1 </span> </a> </li> <li class=md-nav__item> <a href=../oexpltestprograms/test2/ class=md-nav__link> <span class=md-ellipsis> Program 2 </span> </a> </li> <li class=md-nav__item> <a href=../oexpltestprograms/test3/ class=md-nav__link> <span class=md-ellipsis> Program 3 </span> </a> </li> <li class=md-nav__item> <a href=../oexpltestprograms/test4/ class=md-nav__link> <span class=md-ellipsis> Program 4 </span> </a> </li> <li class=md-nav__item> <a href=../oexpltestprograms/test5/ class=md-nav__link> <span class=md-ellipsis> Program 5 </span> </a> </li> <li class=md-nav__item> <a href=../oexpltestprograms/test6/ class=md-nav__link> <span class=md-ellipsis> Program 6 </span> </a> </li> <li class=md-nav__item> <a href=../oexpltestprograms/test7/ class=md-nav__link> <span class=md-ellipsis> Program 7 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_7 checked> <label class=md-nav__link for=__nav_4_7 id=__nav_4_7_label tabindex> <span class=md-ellipsis> Tutorials </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_4_7_label aria-expanded=true> <label class=md-nav__title for=__nav_4_7> <span class="md-nav__icon md-icon"></span> Tutorials </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../lex/ class=md-nav__link> <span class=md-ellipsis> Using LEX </span> </a> </li> <li class=md-nav__item> <a href=../yacc/ class=md-nav__link> <span class=md-ellipsis> Using YACC </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> Using YACC with LEX </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> Using YACC with LEX </span> </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#integrating-lex-with-yacc class=md-nav__link> <span class=md-ellipsis> Integrating LEX with YACC </span> </a> </li> <li class=md-nav__item> <a href=#declaring-tokens class=md-nav__link> <span class=md-ellipsis> Declaring tokens </span> </a> </li> <li class=md-nav__item> <a href=#ytabh class=md-nav__link> <span class=md-ellipsis> y.tab.h </span> </a> </li> <li class=md-nav__item> <a href=#defining-tokens class=md-nav__link> <span class=md-ellipsis> Defining tokens </span> </a> </li> <li class=md-nav__item> <a href=#passing-tokens-from-the-lexer-to-the-parser class=md-nav__link> <span class=md-ellipsis> Passing tokens from the Lexer to the Parser </span> </a> </li> <li class=md-nav__item> <a href=#introduction-to-attributes class=md-nav__link> <span class=md-ellipsis> Introduction to attributes </span> </a> </li> <li class=md-nav__item> <a href=#attribute-synthesis class=md-nav__link> <span class=md-ellipsis> Attribute Synthesis </span> </a> </li> <li class=md-nav__item> <a href=#the-attribute-stack class=md-nav__link> <span class=md-ellipsis> The Attribute Stack </span> </a> </li> <li class=md-nav__item> <a href=#customising-attribute-types class=md-nav__link> <span class=md-ellipsis> Customising Attribute Types </span> </a> <nav class=md-nav aria-label="Customising Attribute Types"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#yystype class=md-nav__link> <span class=md-ellipsis> YYSTYPE </span> </a> </li> <li class=md-nav__item> <a href=#exercise class=md-nav__link> <span class=md-ellipsis> Exercise </span> </a> </li> <li class=md-nav__item> <a href=#example class=md-nav__link> <span class=md-ellipsis> Example </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#references class=md-nav__link> <span class=md-ellipsis> References </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_7_4> <label class=md-nav__link for=__nav_4_7_4 id=__nav_4_7_4_label tabindex=0> <span class=md-ellipsis> GDB </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_7_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4_7_4> <span class="md-nav__icon md-icon"></span> GDB </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../gdb/ class=md-nav__link> <span class=md-ellipsis> Using GDB </span> </a> </li> <li class=md-nav__item> <a href=../gdb-files/ class=md-nav__link> <span class=md-ellipsis> GDB Input Files </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../label-translation/ class=md-nav__link> <span class=md-ellipsis> Label Translation </span> </a> </li> <li class=md-nav__item> <a href=../install/ class=md-nav__link> <span class=md-ellipsis> XSM Simulator Installation </span> </a> </li> <li class=md-nav__item> <a href=../xsmusagespec/ class=md-nav__link> <span class=md-ellipsis> XSM Simulator Instructions </span> </a> </li> <li class=md-nav__item> <a href=../xsm-environment-tut/ class=md-nav__link> <span class=md-ellipsis> XSM Environment Tutorial </span> </a> </li> <li class=md-nav__item> <a href=../library-implementation/ class=md-nav__link> <span class=md-ellipsis> Library Implementation </span> </a> </li> <li class=md-nav__item> <a href=../attribute/ class=md-nav__link> <span class=md-ellipsis> Attribute Synthesis </span> </a> </li> <li class=md-nav__item> <a href=../Data_Structures/ class=md-nav__link> <span class=md-ellipsis> Data Structures for ExpL Compilation/Interpretation </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_8> <label class=md-nav__link for=__nav_4_8 id=__nav_4_8_label tabindex> <span class=md-ellipsis> Misc </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_4_8_label aria-expanded=false> <label class=md-nav__title for=__nav_4_8> <span class="md-nav__icon md-icon"></span> Misc </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../ex1/ class=md-nav__link> <span class=md-ellipsis> Exercise 1 </span> </a> </li> <li class=md-nav__item> <a href=../explusagespec/ class=md-nav__link> <span class=md-ellipsis> ExPL Usage spec? </span> </a> </li> <li class=md-nav__item> <a href=../libinterfaceexpl/ class=md-nav__link> <span class=md-ellipsis> ExPL Library Interface? </span> </a> </li> <li class=md-nav__item> <a href=../help/ class=md-nav__link> <span class=md-ellipsis> help </span> </a> </li> <li class=md-nav__item> <a href=../oexpl/ class=md-nav__link> <span class=md-ellipsis> OExPL </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5 id=__nav_5_label tabindex=0> <span class=md-ellipsis> Student Feedback </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_5_label aria-expanded=false> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> Student Feedback </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../feedback/ class=md-nav__link> <span class=md-ellipsis> Student Feedback </span> </a> </li> <li class=md-nav__item> <a href=../feedback/nitc-winter-2021/ class=md-nav__link> <span class=md-ellipsis> NIT-C Winter 2021 </span> </a> </li> <li class=md-nav__item> <a href=../feedback/nitc-winter-2017/ class=md-nav__link> <span class=md-ellipsis> NIT-C Winter 2017 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#integrating-lex-with-yacc class=md-nav__link> <span class=md-ellipsis> Integrating LEX with YACC </span> </a> </li> <li class=md-nav__item> <a href=#declaring-tokens class=md-nav__link> <span class=md-ellipsis> Declaring tokens </span> </a> </li> <li class=md-nav__item> <a href=#ytabh class=md-nav__link> <span class=md-ellipsis> y.tab.h </span> </a> </li> <li class=md-nav__item> <a href=#defining-tokens class=md-nav__link> <span class=md-ellipsis> Defining tokens </span> </a> </li> <li class=md-nav__item> <a href=#passing-tokens-from-the-lexer-to-the-parser class=md-nav__link> <span class=md-ellipsis> Passing tokens from the Lexer to the Parser </span> </a> </li> <li class=md-nav__item> <a href=#introduction-to-attributes class=md-nav__link> <span class=md-ellipsis> Introduction to attributes </span> </a> </li> <li class=md-nav__item> <a href=#attribute-synthesis class=md-nav__link> <span class=md-ellipsis> Attribute Synthesis </span> </a> </li> <li class=md-nav__item> <a href=#the-attribute-stack class=md-nav__link> <span class=md-ellipsis> The Attribute Stack </span> </a> </li> <li class=md-nav__item> <a href=#customising-attribute-types class=md-nav__link> <span class=md-ellipsis> Customising Attribute Types </span> </a> <nav class=md-nav aria-label="Customising Attribute Types"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#yystype class=md-nav__link> <span class=md-ellipsis> YYSTYPE </span> </a> </li> <li class=md-nav__item> <a href=#exercise class=md-nav__link> <span class=md-ellipsis> Exercise </span> </a> </li> <li class=md-nav__item> <a href=#example class=md-nav__link> <span class=md-ellipsis> Example </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#references class=md-nav__link> <span class=md-ellipsis> References </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=using-lex-with-yacc>USING LEX WITH YACC<a class=headerlink href=#using-lex-with-yacc title="Permanent link">&para;</a></h1> <h2 id=integrating-lex-with-yacc>Integrating LEX with YACC<a class=headerlink href=#integrating-lex-with-yacc title="Permanent link">&para;</a></h2> <p>In the previous documents, we have noted that YACC is used to generate a parser (<a href=../yacc/ >YACC documentation</a>) and LEX is used to generate a lexical analayzer (<a href=../lex/ >LEX documentation</a>). YACC generates the definition for yyparse() in y.tab.c and LEX generates the definition for yylex() in lex.yy.c. We have also noted that yyparse() repetitively calls yylex() to read tokens from the input stream. Till now, for simplicity, we had written a <a href=../yacc/#navexy0al>user-defined yylex()</a> in the YACC program. In this section of the document we will use LEX to generate the definition of yylex() and make YACC use this definition for retrieving tokens.</p> <div class=highlight><pre><span></span><code><span class=cm>/* Declarations section */</span>

<span class=kt>int</span><span class=w> </span><span class=nf>yylex</span><span class=p>();</span>

<span class=o>%%</span>

<span class=cm>/* Rules */</span>

<span class=o>%%</span>

<span class=cm>/* Auxiliary Functions */</span>
</code></pre></div> <p>We should now compile it as <em>gcc y.tab.c lex.yy.c -o &lt;objectfilename&rt;</em></p> <div class="admonition note"> <p class=admonition-title>Note</p> <p>We <strong>must not</strong> provide a <a href=../lex/#navexl0>main() definition in the LEX program</a> calling yylex(), as there already exists a <a href=../yacc/#navexy0al>main() function in the YACC program</a> which calls yyparse() which in turn calls yylex().</p> </div> <p>Recall that yyparse() attempts to parse the given input by calling yylex() to obtain tokens. In the <a href=../yacc/#navexy1>infix to postfix conversion example</a> in the YACC documentation, we had used a <a href=../yacc/#yylex>user defined yylex()</a> in the YACC program. In that example, the YACC program contains the declaration for the token DIGIT in the <a href=../yacc/#navexy1d>declarations section</a> . The definition of the token DIGIT is given in the <a href=../yacc/#navexy1a>auxiliary functions section</a> under the function yylex(). Instead, we will now use LEX to generate yylex().</p> <p>First, we will write a YACC program to declare the tokens and generate yyparse().</p> <h2 id=declaring-tokens>Declaring tokens<a class=headerlink href=#declaring-tokens title="Permanent link">&para;</a></h2> <p>The token DIGIT must be declared in the <em>declaration section</em> to be used in the <em>rules section</em>. The declaration for a token must be made by specifying it in the <a href=../yacc/#decl>YACC declarations section</a> using the <strong>%token</strong> feature offered by YACC. The following example shows the declaration of the token DIGIT in a YACC program.</p> <p><strong>in2post.y</strong> <a name=navy></a> <a name=navyr></a> <a name=navya></a> <div class=highlight><pre><span></span><code>%{
      #include &lt;stdio.h&gt;
%}

%token DIGIT NEWLINE

%%

start : expr NEWLINE  {
                        printf(&quot;\nComplete\n&quot;);
                        exit(1);
                      }
  ;

expr:  expr &#39;+&#39; expr        {printf(&quot;+ &quot;);}
  | expr &#39;-&#39; expr     {printf(&quot;- &quot;);}
  | &#39;(&#39; expr &#39;)&#39;
  | DIGIT             {printf(&quot;%d &quot;,$1);}
  ;

%%

void yyerror(char const *s)
{
    printf(&quot;yyerror  %s\n&quot;,s);
    return ;
}
int main()
{
  yyparse();
  return 1;
}
</code></pre></div></p> <p><a name=navlittok></a> The YACC program given above contains the declaration of the token DIGIT in the <em>declarations section</em>. Note that the grammar contains other terminals like '+', '-', '(' and ')' that also are tokens, but are not declared in the <em>declaration section</em>. These tokens are called <strong>literal tokens</strong>. Literal tokens are tokens with fixed lexemes. This means that the <a href=../lex/#navyytext>lexeme</a> corresponding to a literal token is a single character or a character string. Such a token do not require an expicit declaration in the YACC program.</p> <div class="admonition note"> <p class=admonition-title>Note</p> <p>Conceptually, the lexeme of a literal token can be a character or a string. But, not all versions of YACC support string literal tokens. Hence, in our project we will use only single character literal tokens.</p> </div> <p>Examples of literal tokens:</p> <div class=highlight><pre><span></span><code><span class=sc>&#39;+&#39;</span><span class=w> </span><span class=sc>&#39;*&#39;</span><span class=w> </span><span class=sc>&#39;-&#39;</span>
</code></pre></div> <p>A lexical analyzer returns a token when it finds a corresponding lexeme. In the case of a literal token, the lexical analyzer returns the lexeme itself as the token ( A type coercion to integer is done so that the value returned by yylex() is of integer type.). For example in the <a href=#navyr>above</a> YACC program, on encoutering the pattern '+' in the input file, yylex() returns '+' itself as the token.</p> <p>In the parser, an expression like :</p> <div class=highlight><pre><span></span><code>expr: expr &#39;+&#39; expr
</code></pre></div> <p>is valid because YACC automatically identifies '+' as the literal token.</p> <p>We must now write a LEX program that contains the <a href=../lex/#regdef>regular definition</a> for DIGIT and the literal tokens.</p> <h2 id=ytabh>y.tab.h<a class=headerlink href=#ytabh title="Permanent link">&para;</a></h2> <p>Before writing the LEX program, there must be some way by which the YACC program can tell the LEX program that DIGIT is a valid token that has been declared in the YACC program. This communication is facilitated by the file "y.tab.h" which contains the declarations of all the tokens in the YACC program. The "y.tab.h" is automatically generated by YACC when the 'yacc' command is executed with the -d flag.</p> <p>In order to generate <a href=#integrating-lex-with-yacc>y.tab.c</a> and y.tab.h for the YACC program in in2post.y, do:</p> <div class=highlight><pre><span></span><code>user@localhost:~$ yacc -d in2post.y
</code></pre></div> <p>An example of the contents of y.tab.h file is shown below.</p> <div class=highlight><pre><span></span><code>#define DIGIT 253
</code></pre></div> <p>Note that '253' is a YACC generated constant to represent DIGIT. The constant may vary at different executions of YACC. YACC represents a token by defining a <a href=https://gcc.gnu.org/onlinedocs/cpp/Macros.html>macro identifier</a> corresponding to it.</p> <p>The y.tab.h file must be <em>included</em> in the declarations section of the LEX program. This makes the token declarartions accessible to the LEX program. We will see an example in the next section.</p> <h2 id=defining-tokens>Defining tokens<a class=headerlink href=#defining-tokens title="Permanent link">&para;</a></h2> <p>The next example example shows the definition of DIGIT and the literal tokens in the LEX program.</p> <p><strong>in2post.l</strong> <a name=navl></a> <a name=navyywrapexp></a></p> <div class=highlight><pre><span></span><code>%{
    #include &lt;stdio.h&gt;
   #include &quot;y.tab.h&quot;
%}

%%

[0-9]+ {
          yylval = atoi(yytext);
          return DIGIT;
        }
&quot;+&quot;   return *yytext;
&quot;-&quot;   return *yytext;
[()]   return *yytext;
[\n]      return NEWLINE;

%%

yywrap()
{
 return 1;
}
</code></pre></div> <p>No explicit declaration of the token DIGIT is requied in the LEX program as y.tab.h (which contains the declaration of DIGIT) has been included in the declarations section.</p> <div class="admonition note"> <p class=admonition-title>Note</p> <p>As noted earlier we return the lexeme found in case of <a href=#navlittok>literal tokens</a>: '+','*','(',')'. Note that yylex() is a function of return type int but the above LEX program makes yylex() return *yytext where yytext is a character pointer. *yytext de-references to the character value pointed by yytext. Returning a character value does not cause an error because the C compiler type-casts the value to integer automatically.</p> </div> <p>To generate lex.yy.c, do:</p> <div class=highlight><pre><span></span><code>user@localhost:~$<span class=w> </span>lex<span class=w> </span>in2post.l
</code></pre></div> <p>Once y.tab.c and lex.yy.c files have been generated by YACC and LEX respectively, they can be linked and compiled using the following commands as mentioned earlier. The compilation steps and sample input/output of the above example are shown below:</p> <div class=highlight><pre><span></span><code>user@localhost:~$ gcc lex.yy.c y.tab.c -o in2post.exe
user@localhost:~$ ./in2post.exe
11+22-33
11 22 33 - +
user@localhost:~$
</code></pre></div> <h2 id=passing-tokens-from-the-lexer-to-the-parser>Passing tokens from the Lexer to the Parser<a class=headerlink href=#passing-tokens-from-the-lexer-to-the-parser title="Permanent link">&para;</a></h2> <p>Let us consider the <a href=#navy>YACC</a> and <a href=#navl>LEX</a> programs above.</p> <p>When the input</p> <div class=highlight><pre><span></span><code>11+22-33
</code></pre></div> <p>is given to the executable file (in2post.exe)</p> <ol> <li>The <a href=#navya>main() function</a> in y.tab.c begins execution. It calls yyparse() which inturn calls yylex() for tokens.</li> <li>yylex() reads the input and finds that "11" found in the input matches with the pattern for token DIGIT and returns DIGIT.</li> <li>yyparse() which obtains the token DIGIT, shifts it to the parser stack.</li> <li>A reduction (corresponding to the rule <em>expr: DIGIT</em>) takes place. This results in the terminal getting replaced with the non-terminal(<em>expr</em>) in the parser stack</li> <li>The C statement (semantic action) corresponding to the production is executed (i.e., <em>printf("%d ",$1);</em> is executed.). This prints 11.</li> </ol> <p>We will see what '$1' means and why printing '$1' results in printing the value 11 in detail in the next section.</p> <p>The execution continues in a similar fashion to complete parsing the entire input.</p> <p>A complete illustration of all the shift and reduce steps is given <a href=#the-attribute-stack>later</a>. The parsing steps have been summarised in the below table for now.</p> <table> <thead> <tr> <th>I/P Buffer</th> <th>yylex() returns</th> <th>Parser stack</th> <th>Parser action on stack</th> <th>C Action executed</th> <th>Output Stream</th> </tr> </thead> <tbody> <tr> <td>11 + 22 - 33</td> <td></td> <td></td> <td>_</td> <td></td> <td></td> </tr> <tr> <td>+ 22 - 33</td> <td>DIGIT</td> <td>DIGIT</td> <td>SHIFT</td> <td></td> <td></td> </tr> <tr> <td>+ 22 - 33</td> <td></td> <td>expr</td> <td>REDUCE</td> <td>printf("%d ",$1);</td> <td>11</td> </tr> <tr> <td>22 - 33</td> <td>+</td> <td>expr +</td> <td>SHIFT</td> <td></td> <td>11</td> </tr> <tr> <td>- 33</td> <td>DIGIT</td> <td>expr + 22</td> <td>SHIFT</td> <td></td> <td>11</td> </tr> <tr> <td>- 33</td> <td></td> <td>expr + expr</td> <td>REDUCE</td> <td>printf("%d ",$1);</td> <td>11 22</td> </tr> <tr> <td>33</td> <td>-</td> <td>expr + expr -</td> <td>SHIFT</td> <td></td> <td>11 22</td> </tr> <tr> <td></td> <td>DIGIT</td> <td>expr + expr - DIGIT</td> <td>SHIFT</td> <td></td> <td>11 22</td> </tr> <tr> <td></td> <td>0</td> <td>expr + expr - expr</td> <td>REDUCE</td> <td>printf("%d ",$1);</td> <td>11 22 33</td> </tr> <tr> <td></td> <td></td> <td>expr + expr</td> <td>REDUCE</td> <td>printf("- ");</td> <td>11 22 33 -</td> </tr> <tr> <td></td> <td></td> <td>expr</td> <td>REDUCE</td> <td>printf("+ ");</td> <td>11 22 33 - +</td> </tr> </tbody> </table> <p>Note that yylex() makes a call to yywrap(), when 'End of file' is encountered. We have defined yywrap() to return 1 (We have provided the definition for <a href=#navyywrapexp>yywrap()</a> in our LEX file). <a href=../lex/#navyywrap>Recall</a> that when yylex() receives non-zero value from yywrap(), it returns zero to yyparse(). Also <a href=../yacc/#navyyparse>recall</a> that yyparse() does not call yylex() once it has returned 0. It return zero to main() function to indicate successful parsing.</p> <p>We have noted how to integrate the lexical analyzer generated by LEX with the parser generated by YACC. Now, we will learn more about managing attributes using LEX and YACC..</p> <h2 id=introduction-to-attributes>Introduction to attributes<a class=headerlink href=#introduction-to-attributes title="Permanent link">&para;</a></h2> <p>In the <a href=../yacc/#navpassingvalues>last section</a> of the YACC documentation we have noted that it is possible to pass values associated with tokens from yylex() to yyparse(). We had described the term 'attribute' as a value associated with a token. YACC uses yylval to facilitate passing values from the lexical analyzer to the parser. We will now explore how YACC associates attribute values to terminals and non-terminals in a production. We will also explore the usage of YYSTYPE to define custom (user defined )attribute types.</p> <p><a href=../yacc/#navyylval>Recall</a> that yylval is a global variable declared in y.tab.c of type YYSTYPE (YYSTYPE is integer unless defined otherwise. We will let YYSTYPE take its default type of integer since it is simpler to understand how attributes are processed in this case. Later we will see how more complex attribute types can be defined and handled).</p> <p>In the YACC documentation, we had seen an <a href=../yacc/#navexy1>example</a> which illustrates the passing of attributes from yylex() to yyparse(). We use the variable yylval to hold the attribute to be passed. If the programmer were to use LEX to generate yylex(), then the attributes will have to be passed to yyparse() using the same mechanism i.e, using yylval (see example below).</p> <p>In the LEX program, yylex() returns each token by its name. The attribute associated with each token is assigned to yylval and thus becomes accessible to yyparse(). Note that, all tokens except literal tokens must be declared in the declarations section of the YACC program. The following example is a LEX program which returns a token DIGIT when it finds a number.</p> <p><a name=navpairexp></a> <div class=highlight><pre><span></span><code><span class=o>%</span><span class=p>{</span>
<span class=w>  </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&quot;y.tab.h&quot;</span>
<span class=w>  </span><span class=cp>#include</span><span class=cpf>&lt;stdlib.h&gt;</span>
<span class=w>  </span><span class=cp>#include</span><span class=cpf>&lt;stdio.h&gt;</span>
<span class=o>%</span><span class=p>}</span>

<span class=n>number</span><span class=w>  </span><span class=p>[</span><span class=mi>0-9</span><span class=p>]</span><span class=o>+</span>

<span class=o>%%</span>

<span class=p>{</span><span class=n>number</span><span class=p>}{</span>
<span class=w> </span><span class=n>yylval</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>atoi</span><span class=p>(</span><span class=n>yytext</span><span class=p>);</span>
<span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>DIGIT</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>

<span class=p>.</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=o>*</span><span class=n>yytext</span><span class=p>;</span>

<span class=o>%%</span>
</code></pre></div></p> <p>In this example, we want to return the token DIGIT when an integer is found in the input stream. In addition to the token, we need to pass the value found in the input stream to yyparse(). The lexeme found in the input stream is a string which contains the integer found. <a href=https://en.cppreference.com/w/cpp/string/byte/atoi>atoi()</a> is a built-in function of return type <em>int</em> defined in the <em>stdlib.h</em> header file. We use atoi() to obtain the integer equivalent of the lexeme found. The obtained integer value is then assigned to yylval.</p> <p>The following code segment demonstrates how yyparse() receives the attribute value corresponding to the token DIGIT passed by yylex(). Note that YACC must be run with the <a href=./#navdflag>-d flag</a> to generate y.tab.h. The LEX program above includes the y.tab.h file in the auxiliary declarations section to <em>import</em> the declarations from y.tab.h.</p> <div class=highlight><pre><span></span><code><span class=o>%</span><span class=p>{</span>
<span class=w>    </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;stdio.h&gt;</span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>yyerror</span><span class=p>();</span>
<span class=o>%</span><span class=p>}</span>

<span class=o>%</span><span class=n>token</span><span class=w> </span><span class=n>DIGIT</span>

<span class=o>%%</span>

<span class=nl>start</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;\n&#39;</span><span class=w> </span><span class=p>{</span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;</span><span class=se>\n</span><span class=s>Complete&quot;</span><span class=p>);</span><span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);}</span>
<span class=w> </span><span class=p>;</span>

<span class=nl>expr</span><span class=p>:</span><span class=w>  </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;+&#39;</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=p>{</span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;+ &quot;</span><span class=p>);}</span>
<span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;*&#39;</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=p>{</span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;* &quot;</span><span class=p>);}</span>
<span class=w> </span><span class=o>|</span><span class=w> </span><span class=sc>&#39;(&#39;</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;)&#39;</span>
<span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>DIGIT</span><span class=w>    </span><span class=p>{</span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;%d &quot;</span><span class=p>,</span><span class=n>$1</span><span class=p>);}</span>
<span class=w> </span><span class=p>;</span>

<span class=o>%%</span>

<span class=kt>int</span><span class=w> </span><span class=n>yyerror</span><span class=p>()</span>
<span class=p>{</span>
<span class=w> </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;Error&quot;</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span><span class=w> </span><span class=n>main</span><span class=p>()</span>
<span class=p>{</span>
<span class=w>  </span><span class=n>yyparse</span><span class=p>();</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>Note the semantic action for the production <code>expr:DIGIT</code></p> <div class=highlight><pre><span></span><code><span class=n>DIGIT</span><span class=w> </span><span class=p>{</span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;%d &quot;</span><span class=p>,</span><span class=n>$1</span><span class=p>);}</span>
</code></pre></div> <p>The value corresponding to the token DIGIT, that was assigned to yylval by lex is accessed in YACC using the symbol $1. Recall that values corresponding to the symbols in the handle of a grammar may be accessed using $1, $2, etc according to its position in the production rule.</p> <p>Generally, we say that in the YACC program, the attribute of a grammar symbol in a production can be accessed using the following syntax: $1 for the first symbol in the body of a production, $2 for the second symbol, $3 for the third and so on. For example consider the following example of a YACC rule.</p> <div class=highlight><pre><span></span><code>X: A B C
</code></pre></div> <p>The attribute value of 'A' is accessed by the symbol $1, value of ‘B' by $2 and 'C' can by $3. The symbol $$ refers to the attribute value of ‘X’ which is the head of the production. Note that the head of a production must be a non-terminal. Hence, it becomes possible to assign an attribute value to the head of a production by assigning a value to $$. In the above example, an attribute value can be assigned to X through an assignment to $$. Hence we extend our notion of an attribute to: <em>"An attribute is a value associated with a terminal or non-terminal grammar symbol".</em></p> <p>We will make this clear with an example.</p> <p>Consider the problem of displaying two numbers in an input stream (ending with a ‘\n’) if they occur as a pair separated by a comma. Also suppose that the numbers must be displayed ONLY after a pair is found. Let us look at a YACC program that solves the problem.</p> <p><strong>Example: pair.y</strong></p> <div class=highlight><pre><span></span><code><span class=o>%</span><span class=p>{</span>
<span class=w>  </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;stdio.h&gt;</span>
<span class=w>  </span><span class=kt>int</span><span class=w> </span><span class=nf>yyerror</span><span class=p>();</span>
<span class=o>%</span><span class=p>}</span>

<span class=o>%</span><span class=n>token</span><span class=w> </span><span class=n>DIGIT</span>

<span class=o>%%</span>

<span class=nl>start</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>pair</span><span class=w> </span><span class=sc>&#39;\n&#39;</span><span class=w>  </span><span class=p>{</span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;</span><span class=se>\n</span><span class=s>Complete&quot;</span><span class=p>);</span><span class=w> </span><span class=p>}</span>
<span class=w> </span><span class=p>;</span>

<span class=nl>pair</span><span class=p>:</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=sc>&#39;,&#39;</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;pair(%d,%d),$1,$3&quot;</span><span class=p>);</span><span class=w> </span><span class=p>}</span>
<span class=w>  </span><span class=p>;</span>
<span class=nl>num</span><span class=p>:</span><span class=w> </span><span class=n>DIGIT</span><span class=w>   </span><span class=p>{</span><span class=w> </span><span class=n>$$</span><span class=o>=</span><span class=n>$1</span><span class=p>;</span><span class=w> </span><span class=p>}</span>
<span class=w>  </span><span class=p>;</span>

<span class=o>%%</span>

<span class=kt>int</span><span class=w> </span><span class=n>yyerror</span><span class=p>()</span>
<span class=p>{</span>
<span class=w> </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;Error&quot;</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span><span class=w> </span><span class=n>main</span><span class=p>()</span>
<span class=p>{</span>
<span class=w> </span><span class=n>yyparse</span><span class=p>();</span>
<span class=w> </span><span class=k>return</span><span class=w> </span><span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>We will use the same <a href=#navpairexp>lex program</a> to receive tokens and token values (attributes).</p> <div class="admonition note"> <p class=admonition-title>Note</p> <p>We have assumed that the attribute values of each symbol is an integer. Later we will see how to allow more complex attributes.</p> </div> <p>In the above program segment, the first rule displays the value of the numbers for each pair in the input stream. In the action part of the rule, $1 refers to the attribute value of the first num and $3 refers to the attribute value of the and the second num. (Note that $2 refers to the attribute value of the literal token ',' which is the token itself). Since num is a non-terminal, its attribute cannot be set by yylex(). Recall that every non-terminal symbol in the CFG must have at least one production with the non-terminal as the head. The attribute value of a non-terminal must be set by writing semantic rules to set the value of $$ in such productions. Such an attribute value which is “synthesized” by the semantics actions in a production is called a synthesized attribute. In the example, the attribute value of the non-terminal num is synthesized by the following rule:</p> <div class=highlight><pre><span></span><code>num: DIGIT { $$=$1; }
</code></pre></div> <p>The action of the rule sets the attribute value of num (referred to using $$) to the attribute value of DIGIT (referred to using $1).</p> <p>Sample I/O:</p> <div class=highlight><pre><span></span><code>I: 2,5 O: pair(2,5)
I: 3,5,7 O: syntax error
</code></pre></div> <h2 id=attribute-synthesis>Attribute Synthesis<a class=headerlink href=#attribute-synthesis title="Permanent link">&para;</a></h2> <p>We have seen that attributes of terminals can be passed from yylex() to yyparse(), whereas attributes of a non-terminal can be synthesized. An attribute of a non-terminal grammar symbol is said to be synthesized if it has been calculated from the attribute values of it's children in the parse tree. Thus the (synthesized) attribute associated with a non-terminal is calculated using the attribute values of the symbols in the handle that it replaces. For example, consider the following grammar:</p> <div class=highlight><pre><span></span><code>Z: X {printf(&quot;Result=%d&quot;,$1);}
X: A &#39;+&#39; B { $$ = $1 + $3; }
</code></pre></div> <p>The attribute value of X is a synthesized attribute as it has been calculated using the attribute values of the symbols in the handle (A ‘+’ B) that it replaces.</p> <p>We will look at an example now.</p> <p>This is a YACC program that evaluates an expression:</p> <div class=highlight><pre><span></span><code><span class=o>%</span><span class=p>{</span>
<span class=w>  </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;stdio.h&gt;</span>
<span class=w>  </span><span class=kt>int</span><span class=w> </span><span class=nf>yyerror</span><span class=p>();</span>
<span class=o>%</span><span class=p>}</span>

<span class=o>%</span><span class=n>token</span><span class=w> </span><span class=n>DIGIT</span>

<span class=o>%</span><span class=n>left</span><span class=w> </span><span class=sc>&#39;+&#39;</span>
<span class=o>%</span><span class=n>left</span><span class=w> </span><span class=sc>&#39;*&#39;</span>

<span class=o>%%</span>

<span class=nl>start</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;\n&#39;</span><span class=w>  </span><span class=p>{</span><span class=w> </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;Expression value = %d&quot;</span><span class=p>,</span><span class=n>$1</span><span class=p>);}</span>
<span class=w> </span><span class=p>;</span>

<span class=nl>expr</span><span class=p>:</span><span class=w>  </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;+&#39;</span><span class=w> </span><span class=n>expr</span><span class=w>  </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>$1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>$3</span><span class=p>;}</span>
<span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;*&#39;</span><span class=w> </span><span class=n>expr</span><span class=w>  </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>$1</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>$3</span><span class=p>;}</span>
<span class=w> </span><span class=o>|</span><span class=w> </span><span class=sc>&#39;(&#39;</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;)&#39;</span><span class=w>   </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>$2</span><span class=p>;}</span>
<span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>DIGIT</span><span class=w>   </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>$1</span><span class=p>;}</span>
<span class=w> </span><span class=p>;</span>

<span class=o>%%</span>

<span class=kt>int</span><span class=w> </span><span class=n>yyerror</span><span class=p>()</span>
<span class=p>{</span>
<span class=w> </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;Error&quot;</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span><span class=w> </span><span class=n>main</span><span class=p>()</span>
<span class=p>{</span>
<span class=w>  </span><span class=n>yyparse</span><span class=p>();</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>Sample I/O:</p> <div class=highlight><pre><span></span><code>I: 2+3*(4+5)
O: 29
</code></pre></div> <p>Each of the semantic actions in the following rules synthesizes the attribute value for expr by assignment to $$.</p> <div class=highlight><pre><span></span><code><span class=nl>expr</span><span class=p>:</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;+&#39;</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>$1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>$3</span><span class=p>;}</span>
<span class=w>    </span><span class=o>|</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;*&#39;</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>$1</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>$3</span><span class=p>;}</span>
<span class=w>    </span><span class=o>|</span><span class=w> </span><span class=sc>&#39;(&#39;</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;)&#39;</span><span class=w> </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>$2</span><span class=p>;}</span>
<span class=w>    </span><span class=o>|</span><span class=w> </span><span class=n>DIGIT</span><span class=w> </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>$1</span><span class=p>;}</span>
<span class=w>    </span><span class=p>;</span>
</code></pre></div> <p>We will now see how attribute synthesis is managed internally.</p> <h2 id=the-attribute-stack>The Attribute Stack<a class=headerlink href=#the-attribute-stack title="Permanent link">&para;</a></h2> <p><a href=../yacc/#navshiftreduce>Recall</a> that YACC maintains a parse stack to achieve shift-reduce parsing. The parse stack contains grammar symbols (both terminal and non-terminal ) representing the current configuration of the parser. Similar to the parse stack, YACC also maintains an attribute stack to store the attribute value of each grammar symbol in the parse stack.</p> <p>The attribute stack is synchronous with the parse stack -- synchronous because the i'th value on the attribute stack will be the attribute value of the i'th symbol on the parse stack.</p> <p>We will see how attribute synthesis is done on input 2+3*(4+5).</p> <ol> <li> <p>The main() function in y.tab.c begins execution. It calls yyparse() which in turn calls yylex() for tokens.</p> </li> <li> <p>yylex() reads the input and finds that the lexeme "2" matches with the pattern for the token DIGIT. It assigns ‘2’ to yylval and returns DIGIT. Note that YYSTYPE is assumed to take its default value of integer and hence yylval is set to integer type by YACC.</p> </li> <li> <p>yyparse() which obtains the token DIGIT and its attribute value inside the variable yylval, <a href=../yacc/#navshiftreduce>shifts</a> the token DIGIT to the parser stack and pushes the value of yylval (2) to the attribute stack.</p> <p><div class=two-col> <div> <img src=../img/ywl1.png> <h5>INITIAL PARSE STACK</h5> </div> <div> <img src=../img/ywl1.png> <h5>INITIAL ATTRIBUTE STACK</h5> </div> </div></p> <p><div class=two-col> <div> <img src=../img/ywl2.png> <h5>PARSE STACK - AFTER SHIFT</h5> </div> <div> <img src=../img/ywl3.png> <h5>ATTRIBUTE STACK - AFTER SHIFT</h5> </div> </div></p> </li> <li> <p>A <a href=../yacc/#navshiftreduce>reduction</a> (corresponding to the rule expr: DIGIT) takes place. This results in the following events:</p> <ol> <li> <p>The terminal ‘ DIGIT’ gets replaced with the non-terminal expr in the parser stack.</p> </li> <li> <p>The semantic action {$$=$1} for the corresponding reduction is executed. (This sets the (attribute) value of the non terminal at the head of the rule (‘expr’) to the (attribute) value of the first symbol in the handle (DIGIT).)</p> </li> <li> <p>The value of DIGIT (2) is popped from the attribute stack and the synthesized value of ‘expr’(2) is pushed into it.</p> </li> </ol> <p>Note that at any point in the parser’s execution, the symbols $1, $2, $3 etc., refers to the first, second, third etc. attribute values (of the corresponding tokens) on top of the stack. $$ refers to the attribute value of the non-terminal which is the head of the production. When the non-terminal is pushed on to the parse stack, the value of $$ is pushed on to the attribute stack. $$ refers to the symbol on top of the stack after a reduction has taken place.</p> <p><div class=two-col> <div> <img src=../img/ywl4.png> <h5>PARSE STACK - BEFORE READ</h5> </div> <div> <img src=../img/ywl5.png> <h5>ATTRIBUTE STACK - BEFORE READ</h5> </div> </div></p> <p><div class=two-col> <div> <img src=../img/ywl6.png> <h5>PARSE STACK - AFTER READ</h5> </div> <div> <img src=../img/ywl7.png> <h5>ATTRIBUTE STACK - AFTER READ</h5> </div> </div></p> </li> <li> <p>The parser executes a shift action. Now Lex reads and returns the token ‘+’. Since this is a literal token, its value, ‘+’ gets pushed into both the parse stack and the attribute stack after implicit type coercion .</p> <p><div class=two-col> <div> <img src=../img/ywl8.png> <h5>PARSE STACK - AFTER SHIFT</h5> </div> <div> <img src=../img/ywl9.png> <h5>ATTRIBUTE STACK - AFTER SHIFT</h5> </div> </div></p> </li> <li> <p>Since there are no possible reductions to be performed, parser executes another shift operation. Lex returns the token DIGIT again as it encounters ‘3’. The token DIGIT gets pushed to the parser stack and its value, ‘3’, gets pushed to the attribute stack.</p> <p><div class=two-col> <div> <img src=../img/ywl10.png> <h5>PARSE STACK - AFTER SHIFT</h5> </div> <div> <img src=../img/ywl11.png> <h5>ATTRIBUTE STACK - AFTER SHIFT</h5> </div> </div></p> </li> <li> <p>The reduction by the rule expr: DIGIT takes place. The token DIGIT in parse stack is replaced by ‘expr’. The semantic action {$$=$1} sets the value of ‘expr’ to ‘3. In the attribute stack, the value of DIGIT (3) gets replaced by the value of expr (3 itself).</p> <p><div class=two-col> <div> <img src=../img/ywl12.png> <h5>PARSE STACK - BEFORE READ</h5> </div> <div> <img src=../img/ywl13.png> <h5>ATTRIBUTE STACK - BEFORE READ</h5> </div> </div></p> <p><div class=two-col> <div> <img src=../img/ywl14.png> <h5>PARSE STACK - AFTER READ</h5> </div> <div> <img src=../img/ywl15.png> <h5>ATTRIBUTE STACK - AFTER READ</h5> </div> </div></p> </li> <li> <p>Now even though a valid reduction is possible for expr + expr, the parser executes a shift action. This is because shift/reduce conflict is resolved by looking at operator precedence. <a href=../yacc/#navlookahead>Recall</a> shift/reduce parsing. The next token, ‘*’ is returned by Lex. This is again a literal token and is pushed into both the parse stack and attribute stack.</p> <p><div class=two-col> <div> <img src=../img/ywl16.png> <h5>PARSE STACK - AFTER SHIFT</h5> </div> <div> <img src=../img/ywl17.png> <h5>ATTRIBUTE STACK - AFTER SHIFT</h5> </div> </div></p> </li> <li> <p>Since there are no matching handles in any of the rules, another shift action is executed. Lex returns ‘(‘ which is again a literal token. The configuration is now</p> <p><div class=two-col> <div> <img src=../img/ywl18.png> <h5>PARSE STACK - AFTER SHIFT</h5> </div> <div> <img src=../img/ywl19.png> <h5>ATTRIBUTE STACK - AFTER SHIFT</h5> </div> </div></p> </li> <li> <p>Again, there are no matching rules. So another shift action is executed. Lex returns DIGIT for ‘4’.</p> <p><div class=two-col> <div> <img src=../img/ywl20.png> <h5>PARSE STACK - AFTER SHIFT</h5> </div> <div> <img src=../img/ywl21.png> <h5>ATTRIBUTE STACK - AFTER SHIFT</h5> </div> </div></p> </li> <li> <p>A reduction by expr:DIGIT takes place.</p> <p><div class=two-col> <div> <img src=../img/ywl22.png> <h5>PARSE STACK - BEFORE READ</h5> </div> <div> <img src=../img/ywl23.png> <h5>ATTRIBUTE STACK - BEFORE READ</h5> </div> </div></p> <p><div class=two-col> <div> <img src=../img/ywl24.png> <h5>PARSE STACK - AFTER READ</h5> </div> <div> <img src=../img/ywl25.png> <h5>ATTRIBUTE STACK - AFTER READ</h5> </div> </div></p> </li> <li> <p>Since there are no matching rules, a shift action is executed. The literal token ‘+’ is returned by Lex and pushed into both stacks by YACC.</p> <p><div class=two-col> <div> <img src=../img/ywl26.png> <h5>PARSE STACK - AFTER SHIFT</h5> </div> <div> <img src=../img/ywl27.png> <h5>ATTRIBUTE STACK - AFTER SHIFT</h5> </div> </div></p> </li> <li> <p>Since there are no matching rules, another shift action is executed. Lex returns DIGIT for ‘5’.</p> <p><div class=two-col> <div> <img src=../img/ywl28.png> <h5>PARSE STACK - AFTER SHIFT</h5> </div> <div> <img src=../img/ywl29.png> <h5>ATTRIBUTE STACK - AFTER SHIFT</h5> </div> </div></p> </li> <li> <p>A reduction by the rule expr:DIGIT takes place.</p> <p><div class=two-col> <div> <img src=../img/ywl30.png> <h5>PARSE STACK - BEFORE READ</h5> </div> <div> <img src=../img/ywl31.png> <h5>ATTRIBUTE STACK - BEFORE READ</h5> </div> </div></p> <p><div class=two-col> <div> <img src=../img/ywl32.png> <h5>PARSE STACK - AFTER READ</h5> </div> <div> <img src=../img/ywl33.png> <h5>ATTRIBUTE STACK - AFTER READ</h5> </div> </div></p> </li> <li> <p>The parse stack now contains ‘expr + expr’. Now a reduction by the rule expr : expr ‘+’ expr takes place. The tokens ‘expr’, ‘+’ and ‘expr’ in the parse stack are replaced by a single ‘expr’. The semantic action {$$=$1+$3} executes. $1 and $3 refer to the first and third values in the attribute stack , that is, 4 and 5 respectively. Hence the value of the head($$), ‘expr’, is set to 4+5(=9). ‘4’ ,’+’, and ‘5’ are popped out from the stack and ‘9’ is pushed in.</p> </li> </ol> <p><img alt src=../img/ywl34.png> <img alt src=../img/ywl35.png></p> <p>PARSE STACK-BEFORE READ       ATTRIBUTE STACK-BEFORE READ</p> <p><img alt src=../img/ywl36.png> <img alt src=../img/ywl37.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <ol> <li>Since there are no matching reductions, a shift action takes place. Lexer returns the literal token ‘)’ which is pushed to both parser stack and attribute stack.</li> </ol> <p><img alt src=../img/ywl38.png> <img alt src=../img/ywl39.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <ol> <li>Now a reduction by the rule expr: ‘(‘ expr ‘)’ takes place. The tokens ‘(‘ , expr and ‘)’ in the parser stack are replace by a single expr and the symbols ‘(‘ ,’9’ and ‘)’ in the attribute stack are replaced by ‘9’. (Since the semantic action sets $$ to $2 which is ‘9’).</li> </ol> <p><img alt src=../img/ywl40.png> <img alt src=../img/ywl41.png></p> <p>PARSE STACK-BEFORE READ       ATTRIBUTE STACK-BEFORE READ</p> <p><img alt src=../img/ywl42.png> <img alt src=../img/ywl43.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <ol> <li>Now we have expr*expr on the top of the parser stack. Reduction by the rule expr: expr ‘*’ expr occurs. The tokens ‘expr’, ‘*’ and ‘expr’ are removed from the parse stack and a single ‘expr’ is pushed instead. The symbols ‘3’, ‘*’ and ‘9’ are replaced by ‘27’ (that is, 3*9) in the attribute stack.</li> </ol> <p><img alt src=../img/ywl44.png> <img alt src=../img/ywl45.png></p> <p>PARSE STACK-BEFORE READ       ATTRIBUTE STACK-BEFORE READ</p> <p><img alt src=../img/ywl46.png> <img alt src=../img/ywl47.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <ol> <li>Reduction by the rule expr: expr ‘+’ expr takes place. Now we have a single ‘expr’ in the parser stack and ‘29’ in the attribute stack.</li> </ol> <p><img alt src=../img/ywl48.png> <img alt src=../img/ywl49.png></p> <p>PARSE STACK-BEFORE READ       ATTRIBUTE STACK-BEFORE READ</p> <p><img alt src=../img/ywl50.png> <img alt src=../img/ywl51.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <ol> <li>Finally, lexer returns the ‘\n’ character and the final reduction to ‘start’ occurs by the rule start: expr ‘\n’. The semantic action prints ‘29’.</li> </ol> <p><img alt src=../img/ywl52.png> <img alt src=../img/ywl53.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <p><img alt src=../img/ywl54.png> <img alt src=../img/ywl55.png></p> <p>PARSE STACK-BEFORE READ       ATTRIBUTE STACK-BEFORE READ</p> <p>,/a <img alt src=../img/ywl56.png> <img alt src=../img/ywl57.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <ol> <li> <p>Lexer now encounters end of input (You need to enter Ctrl+D to indicate end of input as input is being read from stdout.) As a result yylex calls yywrap() which returns a non-zero value indication end of input. <a href=../lex/#navyywraplink>yylex()</a> returns 0. (The $ in the input buffer stands for the end of input marker.)</p> </li> <li> <p>When yyparse receives 0 from lexer, it returns 0 to main function to indicate that parsing was successfull.</p> </li> </ol> <p>The following table shows the configuration of the parse stack and the attribute stack at every step of the parsing process. Assume that whenever yylex() returns a token with no attribute, yyparse() pushes a '.' to the attribute stack.</p> <table> <thead> <tr> <th>PARSE STACK</th> <th>ATTRIBUTE STACK</th> <th>I/P BUFFER</th> <th>PARSER-ACTION EXECUTED</th> </tr> </thead> <tbody> <tr> <td></td> <td></td> <td>2 + 3 * (4 + 5) $</td> <td>_</td> </tr> <tr> <td>DIGIT</td> <td>2</td> <td>+ 3 * ( 4 + 5 ) $</td> <td>SHIFT</td> </tr> <tr> <td>expr</td> <td>2</td> <td>+ 3 * ( 4 + 5 ) $</td> <td>REDUCE</td> </tr> <tr> <td>expr +</td> <td>2 .</td> <td>3 * ( 4 + 5 ) $</td> <td>SHIFT</td> </tr> <tr> <td>expr + DIGIT</td> <td>2 . 3</td> <td>* ( 4 + 5 ) $</td> <td>SHIFT</td> </tr> <tr> <td>expr + expr</td> <td>2 . 3</td> <td>* ( 4 + 5) $</td> <td>REDUCE</td> </tr> <tr> <td>expr + expr *</td> <td>2 . 3 .</td> <td>( 4 + 5 ) $</td> <td>SHIFT</td> </tr> <tr> <td>expr + expr * (</td> <td>2 . 3 . .</td> <td>4 + 5 ) $</td> <td>SHIFT</td> </tr> <tr> <td>expr + expr * ( DIGIT</td> <td>2 . 3 . . 4</td> <td>+ 5 ) $</td> <td>SHIFT</td> </tr> <tr> <td>expr + expr * ( expr</td> <td>2 . 3 . . 4</td> <td>+ 5 ) $</td> <td>REDUCE</td> </tr> <tr> <td>expr + expr * ( expr +</td> <td>2 . 3 . . 4 .</td> <td>5 ) $</td> <td>SHIFT</td> </tr> <tr> <td>expr + expr * ( expr + DIGIT</td> <td>2 . 3 . . 4 . 5</td> <td>) $</td> <td>SHIFT</td> </tr> <tr> <td>expr + expr * ( expr + expr</td> <td>2 . 3 . . 4 . 5</td> <td>) $</td> <td>REDUCE</td> </tr> <tr> <td>expr + expr * ( expr</td> <td>2 . 3 . . 9</td> <td>) $</td> <td>REDUCE</td> </tr> <tr> <td>expr + expr * ( expr )</td> <td>2 . 3 . . 9 .</td> <td>$</td> <td>SHIFT</td> </tr> <tr> <td>expr + expr * expr</td> <td>2 . 3 . 9</td> <td>$</td> <td>REDUCE</td> </tr> <tr> <td>expr + expr</td> <td>2 . 27</td> <td>$</td> <td>REDUCE</td> </tr> <tr> <td>expr</td> <td>29</td> <td>$</td> <td>REDUCE</td> </tr> <tr> <td>$expr</td> <td>29</td> <td>$</td> <td>ACCEPT</td> </tr> </tbody> </table> <h2 id=customising-attribute-types>Customising Attribute Types<a class=headerlink href=#customising-attribute-types title="Permanent link">&para;</a></h2> <h3 id=yystype>YYSTYPE<a class=headerlink href=#yystype title="Permanent link">&para;</a></h3> <p>The attribute stack consists of attributes of tokens as well as synthesized attributes. The macro YYSTYPE denotes the type of the attribute stack. For example, in the above production, $$,$1 and $3 are all of the type YYSTYPE. YYSTYPE is <em>int</em> by default. The macro definition</p> <div class=highlight><pre><span></span><code><span class=cp>#define YYSTYPE int</span>
</code></pre></div> <p>can be found in the y.tab.c file. YACC automatically declares yylval to be of the type YYSTYPE.</p> <p>Since by default, YACC defines YYSTYPE to be the type int, only integer valued attributes can be passed from yylex() to yyparse() using the variable <em>yylval</em> and only integer attributes can be synthesized by default. If we were to attempt to assign any other value to <em>yylval</em> or any of the attribute stack variables, a type error would be flagged on compiling y.tab.c using gcc.</p> <p>We will now see how to handle attributes of types other than integer.</p> <p>The default definition of YYSTYPE can overriden with any built-in or userdefined data type. For example if we wanted to print the prefix form of an expression:</p> <div class=highlight><pre><span></span><code><span class=nl>expr</span><span class=p>:</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=n>OP</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;%c %c %c&quot;</span><span class=p>,</span><span class=n>$2</span><span class=p>,</span><span class=n>$1</span><span class=p>,</span><span class=n>$3</span><span class=p>);}</span>
</code></pre></div> <p>The type of YYSTYPE can be overriden manually as shown below. The following line has to be added to the declarations section of the YACC program. This may be used (not recommended) to change the type of all the attributes from int to some other type.</p> <div class=highlight><pre><span></span><code><span class=cp>#define YYSTYPE char</span>
</code></pre></div> <p>In general, YACC sets the type of yylval to that defined by YYSTYPE. Hence, in this case, only character variables and constants can be assigned to yylval.</p> <p>But in order to have multiple custom attribute values, YACC offers a useful feature called <em>%union</em> declaration to customize the type of YYSTYPE. <em>%union</em> declaration is useful when we require to have different tokens return attributes of different types using <em>yylval</em>. For example if we wanted some tokens to be of the type int and some tokens to be of the type char, the following code segment may be added to the declaration section of the YACC program.</p> <div class=highlight><pre><span></span><code><span class=cm>/* YACC Auxiliary declarations*/</span>

<span class=cm>/* YACC Declarations*/</span>

<span class=o>%</span><span class=k>union</span>
<span class=p>{</span>
<span class=w> </span><span class=kt>char</span><span class=w> </span><span class=n>character</span><span class=p>;</span>
<span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>integer</span><span class=p>;</span>

<span class=p>};</span>

<span class=o>%</span><span class=n>token</span><span class=w> </span><span class=n>OP</span>
<span class=o>%</span><span class=n>token</span><span class=w> </span><span class=n>NUMBER</span>

<span class=o>%</span><span class=n>type</span><span class=w> </span><span class=o>&lt;</span><span class=n>character</span><span class=o>&gt;</span><span class=w> </span><span class=n>OP</span>
<span class=o>%</span><span class=n>type</span><span class=w> </span><span class=o>&lt;</span><span class=n>integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>NUMBER</span>

<span class=o>%%</span>

<span class=nl>expr</span><span class=p>:</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=n>OP</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;%c %d %d&quot;</span><span class=p>,</span><span class=n>$</span><span class=o>&lt;</span><span class=n>character</span><span class=o>&gt;</span><span class=mi>2</span><span class=p>,</span><span class=n>$</span><span class=o>&lt;</span><span class=n>integer</span><span class=o>&gt;</span><span class=mi>1</span><span class=p>,</span><span class=n>$</span><span class=o>&lt;</span><span class=n>integer</span><span class=o>&gt;</span><span class=mi>3</span><span class=p>);</span><span class=w> </span><span class=p>}</span>
<span class=w>    </span><span class=o>|</span><span class=w> </span><span class=n>DIGIT</span><span class=w>        </span><span class=p>{</span><span class=w> </span><span class=n>$</span><span class=o>&lt;</span><span class=n>integer</span><span class=o>&gt;</span><span class=n>$</span><span class=o>=</span><span class=n>$</span><span class=o>&lt;</span><span class=n>integer</span><span class=o>&gt;</span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=p>}</span>
<span class=w>    </span><span class=p>;</span>

<span class=o>%%</span>

<span class=cm>/* Auxiliary functions */</span>
</code></pre></div> <p>Note that the type of the attribute of each token must be mentioned when the token is being declared using the following syntax.</p> <div class=highlight><pre><span></span><code>%token tokenname
%type &lt;token-type&gt; tokenname
</code></pre></div> <p>'token-type' must be declared under %union prior to use in the declaration of a token. If the type of a token is not explicitly mentioned, no attribute value can be assigned to the token i.e, it is assumed to be of type void.</p> <h3 id=exercise>Exercise<a class=headerlink href=#exercise title="Permanent link">&para;</a></h3> <p><strong>Use the %union feature for doing the following exercises</strong></p> <div class="admonition question"> <p class=admonition-title>Exercise 1</p> <p>Do Infix to postfix conversion where lexemes are either operators or single characters instead of numbers.</p> <p><strong>Sample input:</strong> a+b*c</p> <p><strong>Sample output:</strong> abc*+</p> <p>The <code>%union</code> feature may be used as follows:</p> <div class=highlight><pre><span></span><code><span class=o>%</span><span class=k>union</span><span class=p>{</span>
<span class=w>    </span><span class=kt>char</span><span class=w> </span><span class=n>c</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> </div> <div class="admonition tip"> <p class=admonition-title>Hint</p> <p>This exercise is similar to infix to postfix conversion in stage 2. Here we need to output the lexemes of a token instead of just the token names. Here each lexeme is a single character. Use yylval to pass the lexemes as the attribute values for each token.</p> </div> <div class="admonition question"> <p class=admonition-title>Exercise 2</p> <p>Do symbolic infix to postfix conversion:</p> <p><strong>Sample input:</strong> hello+my*world</p> <p><strong>Sample output:</strong> hello my world * +</p> </div> <div class="admonition question"> <p class=admonition-title>Exercise 3</p> <p>Do symbolic infix to prefix conversion:</p> <p><strong>Sample input:</strong> hello+my*world</p> <p><strong>Sample output:</strong> + hello * my world</p> </div> <div class="admonition tip"> <p class=admonition-title>Important note</p> <p>Now the attribute values to be passed are strings like “hello”. The simple way to do this is to set YYSTYPE has to be set to char* and pass strings from the lexer to the parser using <em>yylval</em>. To achieve this, we may declare: <div class=highlight><pre><span></span><code>%union{
    char *c;
}
</code></pre></div></p> </div> <p>YACC sets the type of yylval to char*. Hence yylval can hold a pointer to a character string. Note that yytext holds the lexeme that was most recently read by yylex(). Hence, if we were to assign yytext directly to yylval, then yylval would point to this lexeme as required. When yylex() returns the token to yyparse(), this pointer gets pushed to the attribute stack corresponding to the token. However, this method fails because the location that yytext points to gets overwritten when the next lexeme is read from the input by yylex(). Hence the previously read string would be lost from that location. This corrupts the data referenced by the pointer in the attribute stack. To avoid this problem, separate memory should be allocated (using malloc) and the string in yytext should be copied (using strcpy) to this memory and yylval should be set to the newly allocated store. (Alternately the library function strdup may be used. This function allocates a new space, duplicates the string provided as input into this space and returns pointer to it.)</p> <h3 id=example>Example<a class=headerlink href=#example title="Permanent link">&para;</a></h3> <p>Let us look at an example program that creates an expression tree using union.</p> <p>Sample input: 33+42*(21-16)</p> <p>Intermediate data structure: <img alt src=../img/ywlexp0.png></p> <p>Sample output: 243</p> <p>To build such a data structure, we will use a user defined type tnode containing the following fields:</p> <div class=highlight><pre><span></span><code>int flag -  We will set this to 0 or 1 to indicate whether the node is a leaf node storing  an integer value or an internal node.

int val – To store the value in case of leaf node.

char op- To store the operator in case of internal node

struct tnode *right-  To store pointer to right child.

struct tnode *left-  To store pointer to left child.
</code></pre></div> <p>We will create a header file by the name exptree.h for the necessary declarations. This file is to be included in the lex and yacc programs.</p> <div class="admonition note"> <p class=admonition-title>Note</p> <p>Always keep declarations in a header file, function definitions in .c file and include them in your yacc file. This would keep your code clean.</p> </div> <p><strong>exprtree.h</strong></p> <div class=highlight><pre><span></span><code><span class=k>typedef</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=p>{</span>
<span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>val</span><span class=p>;</span><span class=w> </span><span class=c1>//value of the expression tree</span>
<span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>op</span><span class=p>;</span><span class=w> </span><span class=c1>//indicates the opertor</span>
<span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=w> </span><span class=o>*</span><span class=n>left</span><span class=p>,</span><span class=o>*</span><span class=n>right</span><span class=p>;</span><span class=w> </span><span class=c1>//left and right branches</span>
<span class=w> </span><span class=p>}</span><span class=n>tnode</span><span class=p>;</span>

<span class=cm>/*Make a leaf tnode and set the value of val field*/</span>
<span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=o>*</span><span class=w> </span><span class=n>makeLeafNode</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=p>);</span>

<span class=cm>/*Make a tnode with opertor, left and right branches set*/</span>
<span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=o>*</span><span class=w> </span><span class=n>makeOperatorNode</span><span class=p>(</span><span class=kt>char</span><span class=w> </span><span class=n>c</span><span class=p>,</span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=w> </span><span class=o>*</span><span class=n>l</span><span class=p>,</span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=w> </span><span class=o>*</span><span class=n>r</span><span class=p>);</span>

<span class=cm>/*To evaluate an expression tree*/</span>
<span class=kt>int</span><span class=w> </span><span class=nf>evaluate</span><span class=p>(</span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=w> </span><span class=o>*</span><span class=n>t</span><span class=p>);</span>
</code></pre></div> <p>As the lexer scans the input, it should recognise two types of tokens – numbers and operators. ( In the following example we have used literal tokens to indicate each of the operators '+' , '-', '*', '/'. ) The attribute value corresponding to these tokens can be made to indicate which number/operator was read. We will pack this information in the node structure tnode mentioned above .</p> <p><strong>exprtree.l</strong></p> <div class=highlight><pre><span></span><code><span class=o>%</span><span class=p>{</span>
<span class=w> </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;stdlib.h&gt;</span>
<span class=w> </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;stdio.h&gt;</span>
<span class=w> </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&quot;y.tab.h&quot;</span>
<span class=w> </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&quot;exprtree.h&quot;</span>

<span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>number</span><span class=p>;</span>

<span class=o>%</span><span class=p>}</span>

<span class=o>%%</span>

<span class=p>[</span><span class=mi>0-9</span><span class=p>]</span><span class=o>+</span><span class=w> </span><span class=p>{</span><span class=n>number</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>atoi</span><span class=p>(</span><span class=n>yytext</span><span class=p>);</span><span class=w> </span><span class=n>yylval</span><span class=p>.</span><span class=n>no</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>makeLeafNode</span><span class=p>(</span><span class=n>number</span><span class=p>);</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>NUM</span><span class=p>;}</span>
<span class=s>&quot;+&quot;</span><span class=w> </span><span class=p>{</span><span class=k>return</span><span class=w> </span><span class=n>PLUS</span><span class=p>;}</span>
<span class=s>&quot;-&quot;</span><span class=w> </span><span class=p>{</span><span class=k>return</span><span class=w> </span><span class=n>MINUS</span><span class=p>;}</span>
<span class=s>&quot;*&quot;</span><span class=w> </span><span class=p>{</span><span class=k>return</span><span class=w> </span><span class=n>MUL</span><span class=p>;}</span>
<span class=s>&quot;/&quot;</span><span class=w> </span><span class=p>{</span><span class=k>return</span><span class=w> </span><span class=n>DIV</span><span class=p>;}</span>
<span class=p>[</span><span class=w> </span><span class=err>\</span><span class=n>t</span><span class=p>]</span><span class=w> </span><span class=p>{}</span>
<span class=p>[()]</span><span class=w> </span><span class=p>{</span><span class=k>return</span><span class=w> </span><span class=o>*</span><span class=n>yytext</span><span class=p>;}</span>
<span class=p>[</span><span class=err>\</span><span class=n>n</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=k>return</span><span class=w> </span><span class=n>END</span><span class=p>;}</span>
<span class=p>.</span><span class=w> </span><span class=p>{</span><span class=n>yyerror</span><span class=p>(</span><span class=s>&quot;unknown character</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span><span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);}</span>

<span class=o>%%</span>

<span class=kt>int</span><span class=w> </span><span class=n>yywrap</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=k>return</span><span class=w> </span><span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>Notice that yylval is assigned a pointer to newly allocated (using malloc) node of type node. For each token that is a number (DIGIT) or operator(returned as literal tokens '+', '-' , '*', '/' ) that is recognized by the lexer, we pack the information in a node structure and a pointer to this node is passed as attribute to the parser. During reductions, the semantic actions specified in the parser will set the left and the right pointers of these nodes appropriately to complete the creation of the expression tree. We will see how these actions are executed in detail next.</p> <p><strong>exprtree.y</strong></p> <div class=highlight><pre><span></span><code><span class=o>%</span><span class=p>{</span>
<span class=w> </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;stdlib.h&gt;</span>
<span class=w> </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;stdio.h&gt;</span>
<span class=w> </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&quot;exprtree.h&quot;</span>
<span class=w> </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&quot;exprtree.c&quot;</span>
<span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>yylex</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
<span class=o>%</span><span class=p>}</span>

<span class=o>%</span><span class=k>union</span><span class=p>{</span>
<span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=w> </span><span class=o>*</span><span class=n>no</span><span class=p>;</span>

<span class=p>}</span>
<span class=o>%</span><span class=n>type</span><span class=w> </span><span class=o>&lt;</span><span class=n>no</span><span class=o>&gt;</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=n>NUM</span><span class=w> </span><span class=n>program</span><span class=w> </span><span class=n>END</span>
<span class=o>%</span><span class=n>token</span><span class=w> </span><span class=n>NUM</span><span class=w> </span><span class=n>PLUS</span><span class=w> </span><span class=n>MINUS</span><span class=w> </span><span class=n>MUL</span><span class=w> </span><span class=n>DIV</span><span class=w> </span><span class=n>END</span>
<span class=o>%</span><span class=n>left</span><span class=w> </span><span class=n>PLUS</span><span class=w> </span><span class=n>MINUS</span>
<span class=o>%</span><span class=n>left</span><span class=w> </span><span class=n>MUL</span><span class=w> </span><span class=n>DIV</span>

<span class=o>%%</span>

<span class=nl>program</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=n>END</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>$2</span><span class=p>;</span>
<span class=w>    </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;Answer : %d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span><span class=n>evaluate</span><span class=p>(</span><span class=n>$1</span><span class=p>));</span>

<span class=w>    </span><span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
<span class=w>   </span><span class=p>}</span>
<span class=w>  </span><span class=p>;</span>

<span class=nl>expr</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=n>PLUS</span><span class=w> </span><span class=n>expr</span><span class=w>  </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>makeOperatorNode</span><span class=p>(</span><span class=sc>&#39;+&#39;</span><span class=p>,</span><span class=n>$1</span><span class=p>,</span><span class=n>$3</span><span class=p>);}</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=n>MINUS</span><span class=w> </span><span class=n>expr</span><span class=w>   </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>makeOperatorNode</span><span class=p>(</span><span class=sc>&#39;-&#39;</span><span class=p>,</span><span class=n>$1</span><span class=p>,</span><span class=n>$3</span><span class=p>);}</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=n>MUL</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>makeOperatorNode</span><span class=p>(</span><span class=sc>&#39;*&#39;</span><span class=p>,</span><span class=n>$1</span><span class=p>,</span><span class=n>$3</span><span class=p>);}</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=n>DIV</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>makeOperatorNode</span><span class=p>(</span><span class=sc>&#39;/&#39;</span><span class=p>,</span><span class=n>$1</span><span class=p>,</span><span class=n>$3</span><span class=p>);}</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=sc>&#39;(&#39;</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=sc>&#39;)&#39;</span><span class=w>  </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>$2</span><span class=p>;}</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=n>NUM</span><span class=w>   </span><span class=p>{</span><span class=n>$$</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>$1</span><span class=p>;}</span>
<span class=w>  </span><span class=p>;</span>

<span class=o>%%</span>

<span class=n>yyerror</span><span class=p>(</span><span class=kt>char</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=o>*</span><span class=n>s</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;yyerror %s&quot;</span><span class=p>,</span><span class=n>s</span><span class=p>);</span>
<span class=p>}</span>


<span class=kt>int</span><span class=w> </span><span class=n>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>yyparse</span><span class=p>();</span>

<span class=w> </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>The following .c file gives the required function definitions. <strong>exprtree.c</strong></p> <div class=highlight><pre><span></span><code><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=o>*</span><span class=w> </span><span class=n>makeLeafNode</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=w> </span><span class=o>*</span><span class=n>temp</span><span class=p>;</span>
<span class=w>    </span><span class=n>temp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=p>));</span>
<span class=w>    </span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>NULL</span><span class=p>;</span>
<span class=w>    </span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>val</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=p>;</span>
<span class=w>    </span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>NULL</span><span class=p>;</span>
<span class=w>    </span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>NULL</span><span class=p>;</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>temp</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=o>*</span><span class=w> </span><span class=n>makeOperatorNode</span><span class=p>(</span><span class=kt>char</span><span class=w> </span><span class=n>c</span><span class=p>,</span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=w> </span><span class=o>*</span><span class=n>l</span><span class=p>,</span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=w> </span><span class=o>*</span><span class=n>r</span><span class=p>){</span>
<span class=w>    </span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=w> </span><span class=o>*</span><span class=n>temp</span><span class=p>;</span>
<span class=w>    </span><span class=n>temp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=p>));</span>
<span class=w>    </span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>));</span>
<span class=w>    </span><span class=o>*</span><span class=p>(</span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>op</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c</span><span class=p>;</span>
<span class=w>    </span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>l</span><span class=p>;</span>
<span class=w>    </span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>;</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>temp</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=k>struct</span><span class=w> </span><span class=nc>tnode</span><span class=w> </span><span class=o>*</span><span class=n>t</span><span class=p>){</span>
<span class=w>    </span><span class=k>if</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>op</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>NULL</span><span class=p>)</span>
<span class=w>    </span><span class=p>{</span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>t</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>;</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>    </span><span class=k>else</span><span class=p>{</span>
<span class=w>        </span><span class=k>switch</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>op</span><span class=p>)){</span>
<span class=w>            </span><span class=k>case</span><span class=w> </span><span class=sc>&#39;+&#39;</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
<span class=w>                       </span><span class=k>break</span><span class=p>;</span>
<span class=w>            </span><span class=k>case</span><span class=w> </span><span class=sc>&#39;-&#39;</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
<span class=w>                       </span><span class=k>break</span><span class=p>;</span>
<span class=w>            </span><span class=k>case</span><span class=w> </span><span class=sc>&#39;*&#39;</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
<span class=w>                       </span><span class=k>break</span><span class=p>;</span>
<span class=w>            </span><span class=k>case</span><span class=w> </span><span class=sc>&#39;/&#39;</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
<span class=w>                       </span><span class=k>break</span><span class=p>;</span>
<span class=w>        </span><span class=p>}</span>
<span class=w>    </span><span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>Let us now see how the expression tree for the sample input 33+42*(21 - 16) was created.</p> <p>1. On reading the lexeme 33, the lexer recognizes the lexeme as a DIGIT and creates a node, setting its val field to 33. The flag field is set to 0 indicating that the node contains an integer. This node is passed to the parser by setting yylval to a pointer to this node. The token DIGIT is returned by the lexer to the parser. This means that this pointer is pushed into the attribute stack as the value corresponding to the token DIGIT pushed into the parser stack. Note that we have set YYSTYPE to node * so that the attribute stack can hold a pointer to a node structure.</p> <p><img alt src=../img/ywlexp2.png> <img alt src=../img/ywlexp1.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <p>2. Yacc reduces DIGIT to expr following the rule expr : DIGIT and sets the attribute value of expr to the attribute value of INTEGER which is the pointer to the node containing 3. Yacc then calls yylex for the next token.</p> <p><img alt src=../img/ywlexp4.png> <img alt src=../img/ywlexp3.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <p>3. On reading + lexer creates a node and sets its op field to +. The flag field is set to 1 indicating that the node contains an operator. This node is passed to the parser by setting yylval to a pointer to this node.</p> <p><img alt src=../img/ywlexp6.png> <img alt src=../img/ywlexp5.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <p>4. Since no rule in matched in YACC, yylex is called for the next token.</p> <p>5. Similar to step 1, the Lexer returns a node containing 42 and a reduction similar to step 2 takes place in the parser.</p> <p><img alt src=../img/ywlexp8.png> <img alt src=../img/ywlexp7.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <p><img alt src=../img/ywlexp10.png> <img alt src=../img/ywlexp9.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <p>Note that the reduction expr : expr ‘+’ expr does not take place since * has higher precedence over +. The look-ahead hence tells the parser to shift and not reduce [LINK].</p> <p>6. ‘*’ is read and returned similar to step 3. No reduction takes place in YACC since there are no matching rules.</p> <p><img alt src=../img/ywlexp12.png> <img alt src=../img/ywlexp11.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <p>7. The literal token ‘(‘ is read by lexer and passed to YACC. Again, no reduction takes place.</p> <p><img alt src=../img/ywlexp14.png> <img alt src=../img/ywlexp13.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <p>8. The integer 21 is read passed to YACC and subsequent reduction takes place similar to steps 1 and 2.</p> <p><img alt src=../img/ywlexp16.png> <img alt src=../img/ywlexp15.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <p><img alt src=../img/ywlexp18.png> <img alt src=../img/ywlexp17.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <p>9. The operator ‘-‘ is read passed to YACC similar to step 3.</p> <p><img alt src=../img/ywlexp20.png> <img alt src=../img/ywlexp19.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <p>10. The integer 16 is read passed to YACC and subsequent reduction takes place similar to steps 1 and 2.</p> <p><img alt src=../img/ywlexp22.png> <img alt src=../img/ywlexp21.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <p><img alt src=../img/ywlexp24.png> <img alt src=../img/ywlexp23.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <p>11. Now the reduction expr: expr ‘-‘ expr can take place. The nodes containing 21 and 16 are set to the l and r fields of the node containing ‘-‘ and the pointer to ‘-‘ is now the attribute value of the head. The bottom most part of the tree has been created.</p> <p><img alt src=../img/ywlexp26.png> <img alt src=../img/ywlexp25.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <p>12. The literal token ‘(‘ is read and returned. The reduction expr: ‘(‘ expr ‘)’ can now take place. Note how operator precedence is overridden using parentheses.</p> <p><img alt src=../img/ywlexp28.png> <img alt src=../img/ywlexp27.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <p><img alt src=../img/ywlexp30.png> <img alt src=../img/ywlexp29.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <p>13. Now the reduction expr: expr ‘*‘ expr can take place. The nodes containing 4 and ‘-‘ are set to the l and r fields of the node containing ‘*‘ and the pointer to ‘*‘ is now the attribute value of the head. The tree now looks like this:</p> <p><img alt src=../img/ywlexp32.png> <img alt src=../img/ywlexp31.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <p>14. Now the reduction expr: expr ‘+‘ expr can take place. The nodes containing 33 and ‘*‘ are set to the l and r fields of the node containing ‘+‘ and the pointer to ‘+‘ is now the attribute value of the head. The whole tree now looks like this: has been created.</p> <p><img alt src=../img/ywlexp34.png> <img alt src=../img/ywlexp33.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <p>15. Lexer now reads ‘\n’ and finally the reduction program: expr ‘\n’ takes place and the function evaluate is called with the rot node containing ‘+’ passed as argument.</p> <p><img alt src=../img/ywlexp36.png> <img alt src=../img/ywlexp35.png></p> <p>PARSE STACK-AFTER SHIFT       ATTRIBUTE STACK-AFTER SHIFT</p> <p><img alt src=../img/ywlexp38.png> <img alt src=../img/ywlexp37.png></p> <p>PARSE STACK-AFTER READ       ATTRIBUTE STACK-AFTER READ</p> <p>16. An inorder evaluation of the tree returns 243 which is printed as result.</p> <h2 id=references>References<a class=headerlink href=#references title="Permanent link">&para;</a></h2> <p>For further details on the topics covered in this document, the reader may refer to the following :</p> <ol> <li>Compilers : Principles,Techniques and Tools by Alfred V.Aho, Monica S. Lam, Ravi Sethi and Jeffrey D.Ulman .</li> <li>Modern Compiler Implementation in C by Andrew W.Appel</li> <li>Flex &amp; Bison by John Levine</li> <li><a href=http://dinosaur.compilertools.net/ >http://dinosaur.compilertools.net/</a></li> </ol> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg> Back to top </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> <a href=https://creativecommons.org/licenses/by-nc/4.0/ rel=license> <img alt="Creative Commons License" style=border-width:0 src=https://licensebuttons.net/l/by-nc/4.0/80x15.png> </a> National Insititute of Technology, Calicut </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> <div class=md-social> <a href=https://github.com/silcnitc target=_blank rel=noopener title=github.com class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </a> <a href=https://groups.google.com/g/expl-users target=_blank rel=noopener title=groups.google.com class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 488 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "..", "features": ["navigation.tabs", "navigation.top", "navigation.sections"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script> <script src=../assets/javascripts/bundle.fe8b6f2b.min.js></script> </body> </html>